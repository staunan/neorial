<!DOCTYPE html>
<html>
<head>
	<title>Basics - Array</title>
	<link rel="stylesheet" type="text/css" href="../../Assets/bulma.css">
	<link rel="stylesheet" type="text/css" href="../../Assets/Style.css">
	<script src="../Assets/prism.min.js"></script>
	<script type="text/javascript" src="../../Assets/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/prism-dark.css">
</head>
<body class="Body">
<div class="Content Card">



<h1>Declaration</h1>
<p>JavaScript array can be created in two ways -</p>
<pre>
let arr = new Array();
let arr = [];
</pre>
<p class="tip">It is always recomended to use the second approach. Which is more convenitent.</p>
<pre>
let fruits = ["Apple", "Orange", "Plum"];
</pre>







<h1>Accessing</h1>
<p>You can access items using the index starting from 0.</p>
<pre>
let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum
</pre>





<h1>Replacing</h1>
<p>If you assign an item to the index that already exists, the item will be overwritten.</p>
<pre>
fruits[2] = 'Pear'; // now ["Apple", "Orange", "Pear"]
</pre>
<pre>
fruits[3] = 'Lemon'; // now ["Apple", "Orange", "Pear", "Lemon"]
</pre>
<p>In the above example, the index 3 doesn't exist, so it will create a new item in the array.</p>
<p>If can assign an item to the any index you want -</p>
<pre>
let arr = ["Apple", "Orange", "Pear", "Lemon"];
arr[10] = "Guava"; // Okay
</pre>
<p>But in this process, the intermediate index will be treated as undefined. Infact, trying to access an element with the index that is out of array length is not an error. It simply returns <code>undefined</code>.</p>
<p class="tip">Never add an array item this way, unless you know what you are doing. Intermediate gap of index may cause unexpected result when you iterate over the array.</p>










<h1>Trailing Comma</h1>
<p>Just like Object, last array item may end with a trailing comma -</p>
<pre>
let arr = ["Apple", "Orange", "Pear", "Lemon", ];
</pre>





<h1>Type of Elements</h1>
<p>An array can contain any type of data as the item. It can store another array, object, number, string, function, Boolean etc.</p>
<pre>
// mix of values
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// get the object at index 1 and then show its name
alert( arr[1].name ); // John

// get the function at index 3 and run it
arr[3](); // hello
</pre>
<p class="tip">In real life development and business logic, we always store same kind of data model to the array collection. It means each item has the same signature of the of the others.</p>








<h1>Properties and Methods</h1>
<h2>length</h2>
<p>This returns the total number of item exists in the array.</p>
<pre>
let arr = ['Santanu', 'Neo', 'Blaster'];
console.log(arr.length); // Output : 3
</pre>
<p>The length property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.</p>
<pre>
let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
</pre>
<p>Note that we usually don’t use arrays like that. Another interesting thing about the length property is that it’s writable. If we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated.</p>
<pre>
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // truncate to 2 elements
alert( arr ); // [1, 2]

arr.length = 5; // return length back
alert( arr[3] ); // undefined: the values do not return
</pre>

<h2>array.push(item)</h2>
<p>This method adds an item at the end of the array. This methods returns the new <code>array.length</code> after the insertion of new item.</p>
<pre>
let fruits = ['Apple', 'Banana', 'Guava'];
fruits.push('Pear');
log(fruits); // ['Apple', 'Banana', 'Guava', 'Pear']
</pre>
<p>The call fruits.push(...) is equal to fruits[fruits.length]. It can add multiple items at once -</p>
<pre>
fruits.push('Date', 'Coconut');
log(fruits); // ['Apple', 'Banana', 'Guava', 'Pear', 'Date', 'Coconut']
</pre>

<h2>array.pop()</h2>
<p>The pop() method removes the last element from an array. This method doesn't accept any argument.</p>
<pre>
let fruits = ['Apple', 'Banana', 'Guava'];
fruits.pop();
log(fruits); // ['Apple', 'Banana']
</pre>
<p>This method returns the value that was removed.</p>
<pre>
let fruits = ['Apple', 'Banana', 'Guava'];
log(fruits.pop()); // ['Apple', 'Banana']
</pre>

<h2>array.shift()</h2>
<p>This method removes an item from the beginning. It also shift rest of the item to the upwards so that they are indexed properly.</p>
<pre>
let fruits = ['Apple', 'Banana', 'Guava'];
fruits[0]; // Apple
fruits[1]; // Banana
fruits[2]; // Guava
fruits.shift(); // Removes "Apple"
fruits[0]; // Banana
fruits[1]; // Guava
</pre>
<p>This method returns the item that was removed from the beginning. </p>


<h2>array.unshift(item)</h2>
<p>This method adds an item at the beginning and reorder the index.</p>
<pre>
let fruits = ['Apple', 'Banana', 'Guava'];
fruits[0]; // Apple
fruits[1]; // Banana
fruits[2]; // Guava
fruits.unshift("Pear"); // Removes "Apple"
fruits[0]; // Pear
fruits[1]; // Apple
fruits[2]; // Banana
fruits[3]; // Guava
</pre>
<p>It returns the new <code>array.lenght</code> after adding item at the beginning. It can add multiple item at once -</p>
<pre>
let fruits = ['Apple', 'Banana', 'Guava'];
fruits.unshift('Date', 'Coconut'); // ['Apple', 'Banana', 'Guava', 'Date', 'Coconut']
</pre>

<h2>delete</h2>
<p><code>delete</code> operator is used to delete an item. It returns <code>Boolean</code> specifies whether the deletion operation was successful or not.</p>
<pre>
let fruits = ['Apple', 'Banana', 'Guava'];
delete fruits[0];
log(fruits); // ['Banana', 'Guava'];
</pre>
<p>The advantage of delete operator is that you can delete an item from any index you want. And the disadvantage of using <code>delete</code> operator is that, it doesn't reorder the index. If you delete item from the index n, and array[n] will output <code>undefined</code>.</p>
<pre>
let fruits = ['Apple', 'Banana', 'Guava'];
delete fruits[1];
fruits[1]; // undefined
</pre>
<p>Also the <code>length</code> property is not updated. To efficiently delete item from the array consider using <code>splice()</code> or <code>slice()</code> methods.</p>
<pre>
alert(fruites.length); // 3
</pre>
<p>That’s natural, because <code>delete obj.key</code> removes a value by the key. It’s all it does. Fine for objects. But for arrays we usually want the rest of elements to shift and occupy the freed place. We expect to have a shorter array now.</p>

<h2>toString</h2>
<p>Arrays have their own implementation of toString method that returns a comma-separated list of elements.</p>
<pre>
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true

alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
</pre>
<p>So basically if you perform concatenation operation with an array, the array is automatically converted to the string first and then the concatenation happens.</p>

<h2>array.splice()</h2>
<p>The splice method can be used to remove element from the array.</p>
<pre>
var fruits = ["Banana", "Orange", "Apple", "Mango"];
// fruits.splice(index, numberOfitems);
fruits.splice(0,1); // Removes the first element.
fruits.splice(fruits.length-1,1); // Removes the last element.
</pre>
<p>The first argument is the index from which the removing will start. And the second argument specifies the number of item that will be remove from the array.</p>
<p>The splice() methods also accepts any number of additional argument and if they are present they will be added in the array at the index <code>index</code>.</p>
<pre>
var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.splice(1,2, 'Date', 'Coconut'); // ['Banana', 'Date', 'Coconut', 'Mango'];
</pre>
<p>The above example removes 2 items from the index and adds two item(additional arguments) at the index 1.</p>
<p>Removing item using <code>splice()</code> method has advantage over using <code>delete</code> operator. This method automatically reorder the index and update the <code>length</code> property of the array.</p>
<p>This method returns the removed elements -</p>
<pre>
let arr = ["I", "study", "JavaScript", "right", "now"];

// remove 2 first elements
let removed = arr.splice(0, 2);

alert( removed ); // "I", "study" <-- array of removed elements
</pre>
<p>The splice method is also able to insert the elements without any removals. For that we need to set second argument to 0:</p>
<pre>
let arr = ["I", "study", "JavaScript"];

// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");

alert( arr ); // "I", "study", "complex", "language", "JavaScript"
</pre>
<p>Here and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:</p>
<pre>
let arr = [1, 2, 5];

// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
</pre>

<h2>slice()</h2>
<p>The method <code>arr.slice</code> is much simpler than similar-looking <code>arr.splice</code>. The syntax is -</p>
<pre>
arr.slice(start, end)
</pre>
<p>It returns a new array containing all items from index "start" to "end" (not including "end"). Both start and end can be negative, in that case position from array end is assumed.</p>
<p>It works like str.slice, but makes subarrays instead of substrings.</p>
<pre>
let str = "test";
let arr = ["t", "e", "s", "t"];

alert( str.slice(1, 3) ); // es
alert( arr.slice(1, 3) ); // e,s

alert( str.slice(-2) ); // st
alert( arr.slice(-2) ); // s,t
</pre>


<h2>arr.concat()</h2>
<p>This method concats multiple array into one array and returns it.</p>
<pre>
arr.concat(arg1, arg2...)
</pre>
<p>It accepts any number of arguments – either arrays or values. The result is a new array containing items from arr, then arg1, arg2 etc.</p>
<pre>
let arr = [1, 2];

// merge arr with [3,4]
alert( arr.concat([3, 4])); // 1,2,3,4

// merge arr with [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6

// merge arr with [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6
</pre>












<h1>Iteration</h1>
<p>One of the common usage of array to iterate over the array items. We can do this by old school <code>for</code> statement way. Like this -</p>
<pre>
let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i &lt; arr.length; i++) {
  alert( arr[i] );
}
</pre>
<p>That's fine. But there's special type of looping just for array <code>for.. of</code></p>
<pre>
let fruits = ["Apple", "Orange", "Plum"];

// iterates over array elements
for (let fruit of fruits) {
  alert( fruit );
}
</pre>
<p>This way in the first iteration, the first item is copied to the <code>fruit</code>, and in the second iteration, the second item is copied and so on.</p>
<p>Technically, array is an object in JS. So you can use <code>in</code> operator insetead of <code>of</code>, which will be the same result in most cases. But using this is really a bad idea. There are lots of flaws and other disadvantage of using <code>in</code> operator with the for loop.</p>
<pre>
let arr = ["Apple", "Orange", "Pear"];

for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}
</pre>
<p>Remember that, <code>of</code> operator is for looping array and <code>in</code> operator for looping an object.</p>









<h1>Array is actually an Object</h1>
<p>An array is a special kind of object. The square brackets used to access a property arr[0] actually come from the object syntax. Numbers are used as keys. They extend objects providing special methods to work with ordered collections of data and also the length property. But at the core it’s still an object. Remember, there are only 7 basic types in JavaScript. Array is an object and thus behaves like an object. For instance, it is copied by reference:</p>
<pre>
let fruits = ["Banana"]

let arr = fruits; // copy by reference (two variables reference the same array)

alert( arr === fruits ); // true

arr.push("Pear"); // modify the array by reference

alert( fruits ); // Banana, Pear - 2 items now
</pre>
<p>…But what makes arrays really special is their internal representation. The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast. But they all break if we quit working with an array as with an “ordered collection” and start working with it as if it were a regular object. For instance, technically we can do this:</p>
<pre>
let fruits = []; // make an array

fruits[99999] = 5; // assign a property with the index far greater than its length

fruits.age = 25; // create a property with an arbitrary name
</pre>
<p>That’s possible, because arrays are objects at their base. We can add any properties to them. But the engine will see that we’re working with the array as with a regular object. Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.</p>
<p>The ways to misuse an array:</p>
<ul>
	<li>Add a non-numeric property like <code>arr.test = 5</code>.</li>
	<li>Make holes, like: add <code>arr[0]</code> and then <code>arr[1000]</code> (and nothing between them).</li>
	<li>Fill the array in the reverse order, like <code>arr[1000]</code>, <code>arr[999]</code> and so on.</li>
</ul>
<p>Please think of arrays as special structures to work with the ordered data. They provide special methods for that. Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. And if you need arbitrary keys, chances are high that you actually require a regular object <code>{}</code>.</p>






<h1>Performance</h1>
<p>Methods <code>push</code>/<code>pop</code> run fast, while <code>shift</code>/<code>unshift</code> are slow. Consider the following  -</p>
<pre>
fruits.shift(); // take 1 element from the start
</pre>
<p>It’s not enough to take and remove the element with the number 0. Other elements need to be renumbered as well. The <code>shift</code> operation must do 3 things:</p>
<ul>
	<li>Remove the element with the index <code>0</code>.</li>
	<li>Move all elements to the left, renumber them from the index <code>1</code> to <code>0</code>, from <code>2</code> to <code>1</code> and so on.</li>
	<li>Update the <code>length</code> property.</li>
</ul>
<p>The more elements in the array, the more time to move them, more in-memory operations. The similar thing happens with <code>unshift</code>: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.</p>
<p>The pop method does not need to move anything, because other elements keep their indexes. That’s why it’s blazingly fast. The similar thing with the push method.</p>









<h1>new Array()</h1>
<p>There is one more syntax to create an array:</p>
<pre>
let arr = new Array("Apple", "Pear", "etc");
</pre>
<p>It’s rarely used, because square brackets <code>[]</code> are shorter. Also there’s a tricky feature with it. If <code>new Array</code> is called with a single argument which is a number, then it creates an array without items, but with the given <code>length</code>.</p>
<pre>
let arr = new Array(2); // will it create an array of [2] ?

alert( arr[0] ); // undefined! no elements.

alert( arr.length ); // length 2
</pre>
<p>In the code above, <code>new Array(number)</code> has all elements <code>undefined</code>. To evade such surprises, we usually use square brackets, unless we really know what we’re doing.</p>









<h1>Iterate: forEach</h1>
<p>The <code>arr.forEach</code> method allows to run a function for every element of the array.</p>
<pre>
arr.forEach(function(item, index, array) {
  // ... do something with item
});
</pre>
<p>For example -</p>
<pre>
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
</pre>










<h1>Searching in array</h1>
<p>These are methods to search for something in an array.</p>
<h3>indexOf/lastIndexOf and includes</h3>
<p>The methods <code>arr.indexOf</code>, <code>arr.lastIndexOf</code> and <code>arr.includes</code> have the same syntax and do essentially the same as their string counterparts, but operate on items instead of characters:</p>
<ul>
	<li><code>arr.indexOf(item, from)</code> looks for <code>item</code> starting from index <code>from</code>, and returns the index where it was found, otherwise <code>-1</code>.</li>
	<li><code>arr.lastIndexOf(item, from)</code> – same, but looks from right to left.</li>
	<li><code>arr.includes(item, from)</code> – looks for item starting from index from, returns true if found.</li>
</ul>
<pre>
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
</pre>
<p>Note that the methods use <code>===</code> comparison. So, if we look for false, it finds exactly <code>false</code> and not the zero.</p>
<p>If we want to check for inclusion, and don’t want to know the exact index, then arr.includes is preferred.</p>
<p>Also, a very minor difference of includes is that it correctly handles <code>NaN</code>, unlike <code>indexOf</code>/<code>lastIndexOf</code>:</p>
<pre>
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (should be 0, but === equality doesn't work for NaN)
alert( arr.includes(NaN) );// true (correct)
</pre>
<h3>find and findIndex</h3>
<p>Imagine we have an array of objects. How do we find an object with the specific condition? Here the <code>arr.find</code> method comes in handy.</p>
<pre>
let result = arr.find(function(item, index, array) {
  // should return true if the item is what we are looking for
});
</pre>
<p>Here the <code>find</code> method accepts a function which must return Boolean value. The function is called repetitively for each element of the array:</p>
<ul>
	<li><code>item</code> is the element.</li>
	<li><code>index</code> is the its index.</li>
	<li><code>array</code> is the array itself.</li>
</ul>
<p>If the argument method returns <code>true</code>, the search is stopped, the <code>item</code> is returned. If nothing found, <code>undefined</code> is returned.</p>
<p>For example, we have an array of users, each with the fields id and name. Let’s find the one with <code>id == 1</code>:</p>
<pre>
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
</pre>
<p>In real life arrays of objects is a common thing, so the find method is very useful. Note that in the example we provide to find the function <code>item => item.id == 1</code> with one argument. Other arguments of this function are rarely used.</p>
<p>The <code>arr.findIndex</code> method is essentially the same, but it returns the <code>index</code> where the element was found instead of the element itself.</p>

<h3>filter()</h3>
<p>The <code>find</code> method looks for a single (first) element that makes the function return <code>true</code>. If there may be many, we can use <code>arr.filter(fn)</code>. The syntax is roughly the same as <code>find</code>, but it returns an array of matching elements:</p>
<pre>
let results = arr.filter(function(item, index, array) {
  // should return true if the item passes the filter
});
</pre>
<p>For example -</p>
<pre>
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// returns array of the first two users
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
</pre>












<h1>Transform an array</h1>
<p>This section is about the methods transforming or reordering the array.</p>
<h3>map()</h3>
<p>The <code>arr.map</code> method is one of the most useful and often used.</p>
<pre>
let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
});
</pre>
<p>This method has a function as an argument. The returned value of that function is replaced by the array item.</p>
<p>It calls the function for each element of the array and returns the array of results. For instance, here we transform each element into its length:</p>
<pre>
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
</pre>
<p>Here is another example -</p>
<pre>
[1,2,3].map(function(item){return item+1;}); // [2, 3, 4]
</pre>
<p>It doesn't change the original array -</p>
<pre>
let a = [1, 2];
let b = a.map(function(item){return item+1;});
console.log(a); // [1, 2]
console.log(b); // [2, 3]
</pre>
<h3>sort()</h3>
<p>The method  sorts the array in place.</p>
<pre>
['Banana', 'Apple', 'Grape', 'Strawberry', 'Guava', 'Date'].sort();
// ["Apple", "Banana", "Date", "Grape", "Guava", "Strawberry"]
</pre>
<p>For string values, it is fine. But you will get incorrect result for number sort -</p>
<pre>
let arr = [ 1, 2, 15 ];

// the method reorders the content of arr (and returns it)
arr.sort();

alert( arr );  // 1, 15, 2
</pre>
<p>As you can see, the result is incorrect. Because the items are sorted as strings by default. Literally, all elements are converted to strings and then compared. So, the lexicographic ordering is applied and indeed <code>"2" > "15"</code>.</p>
<p>To use our own sorting order, we need to supply a function of two arguments as the argument of <code>arr.sort()</code>.</p>
<p>The function should work like this:</p>
<pre>
function compare(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}
</pre>
<p>For example -</p>
<pre>
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
</pre>
<p>Now it works as intended.</p>
<p>Let’s step aside and see what’s happening. The <code>arr</code> can be array of anything, right? It may contain numbers or strings or html elements or whatever. We have a set of something. To sort it, we need an ordering function that knows how to compare its elements. The default is a string order. The <code>arr.sort(fn)</code> method has a built-in implementation of sorting algorithm. We don’t need to care how it exactly works (an optimized quicksort most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the <code>fn</code> which does the comparison. The algorithm may compare an element multiple times in the process, but it tries to make as few comparisons as possible.</p>
<p>Actually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”. And that allows us to write shorter version of the sort method -</p>
<pre>
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
</pre>
<p>You can also make the code even more smaller using arrow function -</p>
<pre>
arr.sort( (a, b) => a - b );

[2,5,1,-4,6,9,-19,0].sort((a,b)=>a-b); // [-19, -4, 0, 1, 2, 5, 6, 9]
</pre>

<h3>reverse()</h3>
<p>The method <code>arr.reverse()</code> reverses the order of elements in arr and then returns it.</p>
<pre>
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
</pre>

<h3>split</h3>
<p>The method <code>str.split(delim)</code> splits the string into an array by the given delimiter <code>delim</code>.</p>
<pre>
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}
</pre>
<p>The <code>split</code> method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:</p>
<pre>
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);
</pre>
<p>To split a string into array of character, use empty string -</p>
<pre>
"Santanu".split(""); // ["S", "a", "n", "t", "a", "n", "u"]
</pre>


<h3>join()</h3>
<p>The call <code>arr.join(separator)</code> does the reverse to <code>split</code>. It creates a string of <code>arr</code> items glued by separator between them.</p>
<pre>
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';');

alert( str ); // Bilbo;Gandalf;Nazgul

'Santanu'.split("").join(""); // "Santanu"
</pre>








<h1>Array.isArray</h1>
<p>Arrays do not form a separate language type. They are based on objects. So <code>typeof</code> does not help to distinguish a plain object from an array:</p>
<pre>
alert(typeof {}); // object
alert(typeof []); // same
</pre>
<p>You can use <code>Array.isArray()</code> to check if something is an array.</p>
<pre>
alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
</pre>










<h1>Most methods support “thisArg”</h1>
<p>Almost all array methods that call functions – like <code>find</code>, <code>filter</code>, <code>map</code>, with a notable exception of <code>sort</code>, accept an optional additional parameter <code>thisArg</code>.</p>
<pre>
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument
</pre>
<p>The value of <code>thisArg</code> parameter becomes <code>this</code> for <code>func</code>. For instance, here we use an object method as a filter and <code>thisArg</code> comes in handy:</p>
<pre>
let user = {
  age: 18,
  younger(otherUser) {
    return otherUser.age < this.age;
  }
};

let users = [
  {age: 12},
  {age: 16},
  {age: 32}
];

// find all users younger than user
let youngerUsers = users.filter(user.younger, user);

alert(youngerUsers.length); // 2
</pre>
<p>In the call above, we use <code>user.younger</code> as a filter and also provide <code>user</code> as the context for it. If we didn’t provide the context, <code>users.filter(user.younger)</code> would call <code>user.younger</code> as a standalone function, with <code>this=undefined</code>. That would mean an instant error.</p>

















</div>
</body>
</html>
















