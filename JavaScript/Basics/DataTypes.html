<!DOCTYPE html>
<html>
<head>
	<title>Data Types</title>
	<link rel="stylesheet" type="text/css" href="../../Assets/bulma.css">
	<link rel="stylesheet" type="text/css" href="../../Assets/Style.css">
	<script type="text/javascript" src="../../Assets/prism.min.js"></script>
	<script type="text/javascript" src="../../Assets/jquery.min.js"></script>
  <link rel="stylesheet" href="../../Assets/prism-dark.css">
</head>
<body class="Body">
<div class="Content Card">




<h1>Data Types</h1>
<p>A variable in JavaScript can contain any data. A variable can at one moment be a string and later receive a numeric value:</p>
<pre>
// no error
let message = "hello";
message = 123456;
</pre>
<p>Programming languages that allow such things are called “dynamically typed”, meaning that there are data types, but variables are not bound to any of them.</p>
<p>There are five primitive data types in JavaScript. Here we’ll study the basics.</p>
<ul>
	<li>Number</li>
	<li>String</li>
	<li>Boolean</li>
	<li>Null</li>
	<li>Undefined</li>
</ul>




<h1>Number</h1>
<p><code>Number</code> data type represents integer and real(or floating point numnber) number both.</p>
<pre>
let n = 123;
n = 12.345;
</pre>
<h3>Infinity</h3>
<p>Infinity represents the mathematical Infinity ∞. It is a special value that’s greater than any number. We can get it as a result of division by zero or just mention it in the code directly:</p>
<pre>
alert( 1 / 0 ); // Infinity
alert( Infinity ); // Infinity
</pre>
<h3>NaN</h3>
<p><code>NaN</code> represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:</p>
<pre>
alert( "not a number" / 2 ); // NaN, such division is erroneous
</pre>
<p><code>NaN</code> is sticky. Any further operation on <code>NaN</code> would give <code>NaN</code>:</p>
<pre>
alert( "not a number" / 2 + 5 ); // NaN
</pre>
<p>So, if there’s NaN somewhere in a mathematical expression, it propagates to the whole result.</p>
<h3>Mathematical operations are safe</h3>
<p>Doing maths is safe in JavaScript. We can do anything: divide by zero, treat non-numeric strings as numbers, etc. The script will never stop with a fatal error (“die”). At worst we’ll get <code>NaN</code> as the result.</p>
<p>Special numeric values like <code>Infinity</code> and <code>NaN</code> formally belong to the “number” type. Of course they are not numbers in a common sense of this word.</p>





<h1>String</h1>
<p>A string in JavaScript must be quoted.</p>
<pre>
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed ${str}`;
</pre>
<p>In JavaScript, there are 3 types of quotes.</p>
<ul>
	<li>Double quotes: <code>"Hello"</code>.</li>
	<li>Single quotes: <code>'Hello'</code>.</li>
	<li>Backticks: <code>`Hello`</code>.</li>
</ul>
<p>Double and single quotes are “simple” quotes. There’s no difference between them in JavaScript.</p>
<p>Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in <code>${…}</code>, for example:</p>
<pre>
let name = "John";

// embed a variable
alert( `Hello, ${name}!` ); // Hello, John!

// embed an expression
alert( `the result is ${1 + 2}` ); // the result is 3
</pre>
<p>The expression inside <code>${…}</code> is evaluated and the result becomes a part of the string. We can put anything there: a variable like <code>name</code> or an arithmetical expression like <code>1 + 2</code> or something more complex.</p>
<p>Please note that this can only be done in backticks. Other quotes do not allow such embedding!</p>
<pre>
alert( "the result is ${1 + 2}" ); // the result is ${1 + 2} (double quotes do nothing)
</pre>
<h3>There is no character type.</h3>
<p>In some languages, there is a special “character” type for a single character. For example, in the <code>C</code> language and in <code>Java</code> it is <code>char</code>. In JavaScript, there is no such type. There’s only one type: <code>string</code>. A string may consist of only one character or many of them.</p>
<h3>Wrap Text using backticks</h3>
<p>Another advantage of using backticks is that they allow a string to span multiple lines:</p>
<pre>
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // a list of guests, multiple lines
</pre>
<p>If we try to use single or double quotes in the same way, there will be an error:</p>
<pre>
let guestList = "Guests:  // Error: Unexpected token ILLEGAL
  * John";
</pre>





<h1>Boolean</h1>
<p>The boolean type has only two values: <code>true</code> and <code>false</code>.</p>
<p>This type is commonly used to store yes/no values: true means “yes, correct”, and false means “no, incorrect”.</p>
<pre>
let nameFieldChecked = true; // yes, name field is checked
let ageFieldChecked = false; // no, age field is not checked
</pre>
<p>Boolean values also come as a result of comparisons:</p>
<pre>
let isGreater = 4 > 1;

alert( isGreater ); // true (the comparison result is "yes")
</pre>







<h1>Null</h1>
<p>The special <code>null</code> value does not belong to any type of those described above. It forms a separate type of its own, which contains only the <code>null</code> value:</p>
<pre>
let age = null;
</pre>
<p>In JavaScript <code>null</code> is not a “reference to a non-existing object” or a “null pointer” like in some other languages.</p>
<p>It’s just a special value which has the sense of “nothing”, “empty” or “value unknown”.</p>
<p>The code above states that the age is unknown or empty for some reason.</p>








<h1>Undefined</h1>
<p>The special value <code>undefined</code> stands apart. It makes a type of its own, just like <code>null</code>. The meaning of <code>undefined</code> is “value is not assigned”.</p>
<p>If a variable is declared, but not assigned, then its value is exactly <code>undefined</code>:</p>
<pre>
let x;

alert(x); // shows "undefined"
</pre>
<p>Technically, it is possible to assign <code>undefined</code> to any variable:</p>
<pre>
let x = 123;

x = undefined;

alert(x); // "undefined"
</pre>
<p>…But it’s not recommended to do that. Normally, we use <code>null</code> to write an “empty” or an “unknown” value into the variable, and <code>undefined</code> is only used for checks, to see if the variable is assigned or similar.</p>




<h1>The typeof operator</h1>
<p>The <code>typeof</code> operator returns the type of the argument. It’s useful when we want to process values of different types differently, or just want to make a quick check.</p>
<p>It supports two forms of syntax:</p>
<ul>
	<li>As an operator: <code>typeof x</code>.</li>
	<li>Function style: <code>typeof(x)</code>.</li>
</ul>
<p>In other words, it works both with parentheses or without them. The result is the same. The call to <code>typeof x</code> returns a string with the type name:</p>
<pre>
typeof undefined // "undefined"

typeof 0 // "number"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
</pre>
<p>The result of <code>typeof null</code> is "object". That’s wrong. It is an officially recognized error in typeof, kept for compatibility. Of course, <code>null</code> is not an object. It is a special value with a separate type of its own. So, again, that’s an error in the language.</p>







<h1>Type Conversions</h1>
<p>Most of the time, operators and functions automatically convert a value to the right type. That’s called “Implicit type conversion”. For example <code>alert</code> function automatically converts any value to string and display the alert. Mathematical operations convert values to numbers. There is a lots of scinario where automatic conversion happens to the target type. But it's hard to remember all of them. So when you are not sure if a value will be converted to the right type, you can explicitily convert the value to the taget type.</p>



<h1>Converting to String</h1>
<pre>
String(value);
</pre>
<p>For example -</p>
<pre>
var i = 39, flag = false;
i=String(i);
console.log(typeof i); // string
var b = String(flag);
console.log(typeof b); // string
</pre>
<p>String conversion is mostly obvious. A <code>false</code> becomes <code>"false"</code>, <code>null</code> becomes <code>"null"</code> etc.</p>









<h1>Converting to Number</h1>
<pre>
Number(value)
</pre>
<pre>
let str = "123";
alert(typeof str); // string

let num = Number(str); // becomes a number 123

alert(typeof num); // number
</pre>
<p>If the string is not a valid number, the result of such conversion is <code>NaN</code>, for instance:</p>
<pre>
let age = Number("an arbitrary string instead of a number");

alert(age); // NaN, conversion failed
</pre>
<p>The followings are few rules for converting to number type -</p>
<ul>
	<li><code>undefined</code> becomes <code>NaN</code></li>
	<li><code>null</code> becomes 0</li>
	<li><code>true</code> becomes 1 and <code>false</code> becomes 0</li>
	<li>Whitespaces from the start and the end are removed. Then, if the remaining string is empty, the result is 0. Otherwise, the number is “read” from the string. An error gives <code>NaN</code>.</li>
</ul>
<pre>
alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error reading a number at "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
</pre>







<h1>Implicit Conversion when using +</h1>
<p>Almost all mathematical operations convert values to numbers. With a notable exception of the addition +. If one of the added values is a string, then another one is also converted to a string.</p>
<pre>
alert( 1 + '2' ); // '12' (string to the right)
alert( '1' + 2 ); // '12' (string to the left)
</pre>
<p>That only happens when one of the arguments is a string. Otherwise, values are converted to numbers.</p>










<h1>Converting to Boolean</h1>
<pre>
Boolean(value)
</pre>
<p>Here is the rules for converting to Boolean type -</p>
<ul>
	<li>Values that are intuitively “empty”, like 0, an empty string, <code>null</code>, undefined and NaN become <code>false</code>.</li>
	<li>Other values become <code>true</code>.</li>
</ul>
<pre>
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hello") ); // true
alert( Boolean("") ); // false
</pre>
<h3>Please note: the string with zero "0" is true</h3>
<p>Some languages (namely PHP) treat "0" as false. But in JavaScript a non-empty string is always true.</p>
<pre>
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // spaces, also true (any non-empty string is true)
</pre>









<h1>parseInt() and parseFloat()</h1>
<p>These two function converts string value to Integer and Float type respectively and returns it.</p>
<pre>
parseInt(stringValue, radix);
parseFloat(stringValue, radix);
</pre>
<p>Here, <code>radix</code>is an integer between 2 and 36 that represents the radix (the base in mathematical numeral systems) of the above mentioned string. By default it is <code>10</code>, so most of the time we do not need to use the second argument as we most of the time deal only with decimal number system.</p>
<p>It is very powerful then the function <code>Number(value)</code>. If your string starts with number and ends with string, then this function extract the digits from the string and returns it.</p>
<p>Here are some example -</p>
<pre>
parseInt("30"); // 30
parseInt("30santanu"); // 30
parseInt("s30antanu"); // NaN
parseInt("0") // 0
parseInt("") // NaN
parseInt(false) // NaN
parseInt(undefined) // NaN
parseInt(null) // NaN
parseInt(Infinity) // NaN
parseInt(NaN) // NaN
</pre>
<p><code>parseFloat()</code> works the same way, except it returns the float value.</p>














</div>
</body>
</html>