<!DOCTYPE html>
<html>
<head>
	<title>Custom Events</title>
	<link rel="stylesheet" type="text/css" href="../../Assets/bulma.css">
	<link rel="stylesheet" type="text/css" href="../../Assets/Style.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.4/prism.min.js"></script>
	<script type="text/javascript" src="../../Assets/jquery.min.js"></script>
  <link rel="stylesheet" href="../../Assets/prism-dark.css">
</head>
<body class="Body">
<div class="Content Card">



<h1>Create Custom Event</h1>
<pre>
let event = new Event(event_type [, options]);
</pre>
<p>Here, <code>event_type</code> is the name of the event and must not match with any predefined events.</p>
<p>The argument <code>options</code> is an object. Which has only two properties. One is <code>bubbles</code> and last is <code>cancelable</code>. If bubble is <code>true</code>, then the event bubbles upto the topmost element. By default it is <code>false</code>. If <code>cancelable</code> property is set to true, then the “default action” may be prevented.</p>
<pre>
let event = new Event("notified", {
	bubble : true,
	cancelable : false,
});
</pre>








<h1>dispatchEvent</h1>
<p>After an event object is created, we should “run” it on an element using the call <code>elem.dispatchEvent(event)</code>. Then handlers react on it as if it were a regular built-in event. If the event was created with the bubbles flag, then it bubbles.</p>
<p>Here is an example -</p>
<pre>
&lt;button onclick="startEvent1()" id="button1">Car&lt;/button>
&lt;script type="text/javascript">
	button1.addEventListener("purchase", function(event){
		alert("Thank you for purchasing "+ event.target.textContent);
		alert("Trusted Event = " + event.isTrusted);
	});
	function startEvent1(){
		// Do other stuff --
		alert("Creating Event and Dispatching");
		var event = new Event('purchase');
		button1.dispatchEvent(event);
	}
&lt;/script>

</pre>
<div class="box">
<button onclick="startEvent1()" id="button1">Car</button>
<script type="text/javascript">
	button1.addEventListener("purchase", function(event){
		alert("Thank you for purchasing "+ event.target.textContent);
		alert("Trusted Event = " + event.isTrusted);
	});
	function startEvent1(){
		// Do other stuff --
		alert("Creating Event and Dispatching");
		var event = new Event('purchase');
		button1.dispatchEvent(event);
	}
</script>
</div>
<p>There are few things you should remember when you are using custom events -</p>
<ul>
	<li>We should use <code>addEventListener</code> for our custom events, because <code>on&lt;event></code> only exists for built-in events, document.onhello doesn’t work.</li>
	<li>Must set <code>bubbles:true</code>, otherwise the event won’t bubble up.</li>
	<li>When <code>bubbles</code> is set to <code>true</code>, it also includes <code>capturing phase</code>.</li>
</ul>





<h1>Event.isTrusted</h1>
<p>Event can be occured in two ways - </p>
<ul>
	<li>When a user interect with the output devices(real user actions).</li>
	<li>Event is generated from within the script.</li>
</ul>
<p>If an event is generated by some output devices then the property <code>isTrusted</code> is true. And if the event is generated by some script, then the property <code>isTrusted</code> is false.</p>










<h1>Bubbling Example</h1>
<p>We can create a bubbling event with the name "hello" and catch it on document. All we need is to set <code>bubbles</code> to <code>true</code>:</p>
<pre>
&lt;button id="button2">Bubble Effect&lt;/button>
&lt;script>
  // catch on document...
  document.addEventListener("hello", function(event) { // (1)
    alert("Hello from " + event.target.tagName); // Hello from H1
  });
  button2.onclick = function(event){
  	// ...dispatch on elem!
	  let event1 = new Event("hello", {bubbles: true}); // (2)
	  button2.dispatchEvent(event1);
  };
&lt;/script>
</pre>
<div class="box">
<button id="button2">Bubble Effect</button>
<script>
  // catch on document...
  document.addEventListener("hello", function(event) { // (1)
    alert("Hello from " + event.target.tagName); // Hello from H1
  });
  button2.onclick = function(event){
  	// ...dispatch on elem!
	  let event1 = new Event("hello", {bubbles: true}); // (2)
	  button2.dispatchEvent(event1);
  };
</script>
</div>










<h1>Dispatching In-Built Events</h1>
<p>If you want to create a inbuilt event and dispatch it you should use the specific class for specific event instead of using <CODE>Event</CODE> class. For example, if you want to create an event that is generated by mouse click, you can use inbuilt event <code>MouseEvent</code> class instead of <code>Event</code> class. The right constructor allows to specify standard properties for that type of event. Here is an example -</p>
<pre>
let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // 100
</pre>
<p>Here we can add more properties that are only acceptable by <code>MouseEvent</code> class. If you used <code>Event</code> class, it wouldn't work -</p>
<pre>
let event = new Event("click", {
  bubbles: true, // only bubbles and cancelable
  cancelable: true, // work in the Event constructor
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // undefined, the unknown property is ignored!
</pre>
<p>Technically, we can work around that by assigning directly event.clientX=100 after creation. But still, using the proper type of the event class is the standard way.</p>












<h1>CustomEvent</h1>
<p>If you want to create a custom event, you can use <code>CustomEvent</code> class instead of <code>Event</code> class. Technically <code>CustomEvent</code> is the same as <code>Event</code>, with one exception.</p>
<p>In the second argument (object) we can add an additional property detail for any custom information that we want to pass with the event.</p>
<pre>
&lt;h1 id="elem">Hello for John!&lt;/h1>

&lt;script>
  // additional details come with the event to the handler
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "John" }
  });
&lt;/script>
</pre>
<p>The <code>detail</code> property can have any data. Technically we could live without, because we can assign any properties into a regular new <code>Event</code> object after its creation. But <code>CustomEvent</code> provides the special <code>detail</code> field for it to evade conflicts with other event properties.</p>
<p>The event class tells something about “what kind of event” it is, and if the event is custom, then we should use <code>CustomEvent</code> just to be clear about what it is.</p>









<h1>event.preventDefault()</h1>
<p>We can call <code>event.preventDefault()</code> on a script-generated event if <code>cancelable:true</code> flag is specified.</p>
<p>Of course, if the event has a non-standard name, then it’s not known to the browser, and there’s no “default browser action” for it. But the event-generating code may plan some actions after <code>dispatchEvent</code>. The call of <code>event.preventDefault()</code> is a way for the handler to send a signal that those actions shouldn’t be performed. In that case the call to <code>elem.dispatchEvent(event)</code> returns false. And the event-generating code knows that the processing shouldn’t continue.</p>

<p>In the following example, there’s a <code>hide()</code> function. It generates the "hide" event on the element #rabbit, notifying all interested parties that the rabbit is going to hide. A handler set by <code>rabbit.addEventListener('hide',...)</code> will learn about that and, if it wants, can prevent that action by calling <code>event.preventDefault()</code>. Then the rabbit won’t hide:</p>
<pre>
&lt;pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o&lt;}
&lt;/pre>

&lt;script>
  // hide() will be called automatically in 2 seconds
  function hide() {
    let event = new CustomEvent("hide", {
      cancelable: true // without that flag preventDefault doesn't work
    });
    if (!rabbit.dispatchEvent(event)) {
      alert('the action was prevented by a handler');
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener('hide', function(event) {
    if (confirm("Call preventDefault?")) {
      event.preventDefault();
    }
  });

  // hide in 2 seconds
  setTimeout(hide, 2000);

&lt;/script>
</pre>





<h1>Nested Event, Events, All are Synchronous</h1>
<p>Events are processed synchronously. It means Javascript wait for one event to complete to start another one. If you dispatch an event within another event then the control jumps into the nested event and when the nested event is completely fully processed, then the controll goes back to calling handler and continue executing.</p>
<pre>
	&lt;button id="button4">Click&lt;/button>
	&lt;script type="text/javascript">
		button4.addEventListener("check",function(){
			console.log("Nested - Start");
			var i = 0;
			while(i&lt;100){
				i++;
				console.log(i);
			}
			console.log("Nested - End");
		});
		button4.onclick=function(event){
			console.log("Outer - Start");
			console.log("Start Dispatching");
			var event2 = new CustomEvent("check");
			button4.dispatchEvent(event2);
			console.log("End Dispatching");
			console.log("Outer - End");
		};
	&lt;/script>
</pre>
<div class="box">
	<button id="button4">Click</button>
	<script type="text/javascript">
		button4.addEventListener("check",function(){
			console.log("Nested - Start");
			var i = 0;
			while(i<100){
				i++;
				console.log(i);
			}
			console.log("Nested - End");
		});
		button4.onclick=function(event){
			console.log("Outer - Start");
			console.log("Start Dispatching");
			var event2 = new CustomEvent("check");
			button4.dispatchEvent(event2);
			console.log("End Dispatching");
			console.log("Outer - End");
		};
	</script>
</div>
<p>Here is another example -</p>
<pre>
&lt;button id="button5">Click&lt;/button>
&lt;script type="text/javascript">
button5.onclick=function(){
	var i = 0;
	while(i&lt;10000000){
		i++;
	}
	console.log("Inside the Handler");
};
console.log("Start Dispatching");
var event3 = new MouseEvent("click");
button5.dispatchEvent(event3);
console.log("Outside the Handler");
&lt;/script>
</pre>
<div class="box">
<button id="button5">Click</button>
<script type="text/javascript">
button5.onclick=function(){
	var i = 0;
	while(i<10000000){
		i++;
	}
	console.log("Inside the Handler");
};
console.log("Start Dispatching");
var event3 = new MouseEvent("click");
button5.dispatchEvent(event3);
console.log("Outside the Handler");
</script>
</div>




















</div>
</body>
</html>